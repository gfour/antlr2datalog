/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package org.clyze.antlr2datalog;

import org.antlr.v4.runtime.*;
import org.antlr.v4.runtime.Parser;
import org.antlr.v4.runtime.tree.*;
import org.apache.commons.cli.*;

import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import java.lang.reflect.Method;
import java.net.MalformedURLException;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * The main application.
 */
public class Main {
    /** Global debug flag. */
    public static boolean debug = false;

    /**
     * The main entry point.
     * @param args  the command-line arguments
     */
    public static void main(String[] args) {
        Options options = new Options();

        Option irOpt = new Option("i", "input", true, "File or directory containing source files.");
        irOpt.setRequired(true);
        irOpt.setArgName("PATH");
        irOpt.setArgs(Option.UNLIMITED_VALUES);
        options.addOption(irOpt);

        Option langOpt = new Option("l", "language", true, "Parser language (available values: " + Arrays.toString(ParserConfiguration.values()) + ").");
        langOpt.setRequired(true);
        langOpt.setArgName("LANGUAGE");
        options.addOption(langOpt);

        Option factsOpt = new Option("f", "facts", true, "Fact generation directory.");
        factsOpt.setRequired(true);
        factsOpt.setArgName("PATH");
        options.addOption(factsOpt);

        Option debugOpt = new Option("d", "debug", false, "Enable debug mode.");
        options.addOption(debugOpt);

        if (args.length == 0) {
            printUsage(options);
            return;
        }

        ParserConfiguration parserConfiguration;
        String factsDir;
        String[] inputs;
        CommandLineParser parser = new GnuParser();
        try {
            CommandLine cli = parser.parse(options, args);
            if (cli.hasOption(debugOpt.getOpt()))
                debug = true;
            String lang = cli.getOptionValue('l');
            factsDir = cli.getOptionValue('f');
            inputs = cli.getOptionValues('i');
            System.out.println("Using language: " + lang);
            System.out.println("Using facts directory: " + factsDir);
            parserConfiguration = ParserConfiguration.valueOf(lang.toUpperCase());
            parserConfiguration.load();
        } catch (ParseException | MalformedURLException | ClassNotFoundException e) {
            e.printStackTrace();
            printUsage(options);
            return;
        }

        System.out.println("Discovering schema...");
        Map<Class<?>, Rule> schema = getSchema(parserConfiguration);

        System.out.println("Recording facts...");
        Map<String, Collection<String>> tables = new HashMap<>();
        Database db = new Database(tables, factsDir);
        AtomicInteger counter = new AtomicInteger(0);
        for (String path : inputs)
            parseFile(schema, db, counter, parserConfiguration, path);
        db.writeFacts();
    }

    private static void parseFile(Map<Class<?>, Rule> schema, Database db, AtomicInteger counter, ParserConfiguration pc, String path) {
        boolean ignore = true;
        for (String ext : pc.extensions)
            if (path.endsWith(ext)) {
                ignore = false;
                break;
            }
        if (ignore) {
            System.out.println("Ignoring: " + path);
            return;
        }
        try (InputStream inputStream = new FileInputStream(path)) {
            Lexer lexer = pc.lexerClass.getConstructor(CharStream.class).newInstance(CharStreams.fromStream(inputStream));
            TokenStream tokenStream = new CommonTokenStream(lexer);
            Parser parser = pc.parserClass.getConstructor(TokenStream.class).newInstance(tokenStream);
            ParserRuleContext ruleContext = (ParserRuleContext) pc.parserClass.getDeclaredMethod(pc.rootNode).invoke(parser);
            process(db, path, schema, counter, ruleContext);
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    private static Map<Class<?>, Rule> getSchema(ParserConfiguration parserConfiguration) {
        String rootNode = parserConfiguration.rootNode;
        SchemaFinder sf = new SchemaFinder();
        try {
            Method rootNodeMethod = parserConfiguration.parserClass.getDeclaredMethod(rootNode);
            Class<? extends ParseTree> rootNodeClass = (Class<? extends ParseTree>)rootNodeMethod.getReturnType();
            sf.discoverSchema(rootNodeClass);
            sf.printSchema(new File("schema.dl"));
        } catch (NoSuchMethodException ex) {
            throw new RuntimeException("Root node does not exist: " + rootNode);
        }
        return sf.schema;
    }

    private static void process(Database db, String path, Map<Class<?>, Rule> schema, AtomicInteger counter, ParserRuleContext rootNode) {
        int fileId = counter.getAndIncrement();
        db.writeRow("Source_File_Id", path + '\t' + fileId);
        FactVisitor fv = new FactVisitor(fileId, schema, db);
//        fv.visit(rootNode);
        rootNode.accept(new ParseTreeVisitor<Void>() {
            @Override
            public Void visit(ParseTree parseTree) {
                fv.visitParseTree(new TypedParseTree(parseTree, parseTree.getClass()));
                return null;
            }

            @Override
            public Void visitChildren(RuleNode ruleNode) {
                return visit(ruleNode);
            }

            @Override
            public Void visitTerminal(TerminalNode terminalNode) {
                return null;
            }

            @Override
            public Void visitErrorNode(ErrorNode errorNode) {
                return null;
            }

        });
    }

    private static void printUsage(Options options) {
        HelpFormatter formatter = new HelpFormatter();
        formatter.setWidth(100);
        formatter.printHelp("antlr2datalog [OPTION]...", options);
    }
}
